#summary Summary of design questions and resolutions so far
#sidebar TableOfContents

This is an attempt to break the problem down into a series of design decisions where we can test how much agreement there is on each.

The current breakdown is probably not right and certainly not complete. The summary of status is probably wrong in many cases. Please improve.

All references to _round-tripping_ below are subject to the caveat that our aims place inverting the mapping back to RDF as non-requirement, just an added bonus. However, where round-tripping breaks that does mean the mapping is ambiguous and that might impact some applications even when full inversion isn't involved.

<wiki:toc max_depth="3" />

= API Issues =

Our AIM is a RESTful API through which a web developer can access a linked data endpoint. For the moment we are focusing on what comes back over the wire.

== API result wrapper ==

The common case to support is APIs which returns lists of (possibly ordered) matching resources and their associated RDF descriptions. What constitutes a _match_ and an _appropriate description_ may be entirely driven by the publisher or they may provide a rich query API. 

The API returns an outer JSON wrapper such as:

{{{
{
    "format" : "linked-data-api",
    "version" : "0.1",
    "mapping" : ... ,     // Not required, supports inversion
    "results" : [...]    // The resource descriptions
}
}}}

*Status*: Discussed, not agreed. Not clear if even the notion of having a wrapper is agreed and details certainly still open, both their nature and name. For example "results" might be better as "graph".

== JSONP support ==

API should support a JSONP type callback in which case the result wrapper is actually passed to the callback wrapper.

*Status*: Agreed?

== Mapping and context ===

The wrapper should include an object which records enough of the mapping from the source RDF to the JSONs to allow some inversion (turn the JSON back into RDF, which at least partial round tripping). Developers who don't care about the RDF mapping should find it easy ignore this mapping information.

At a minimum this mapping information should allow property names (and any abbreviated resource identifiers) to be mapped to URIs. 

RDFj does this via a `"context"` property on the outermost object:

{{{
"context": {
    "base": ...,
    "token": ...
  }
}}}

Exhibit uses a `"properties"` table which also includes (inferred) range information to allow the type of the property values to be handled appropriately.

{{{
"properties" : {
    "sampleQuery" :       {
        "uri" :       "http://www.epimorphics.com/example#sampleQuery",
        "valueType" : "item"
    },
    "number-of-triples" : {
        "uri" :       "http://www.epimorphics.com/example#numTriples",
        "valueType" : "number"
    }
    ...
}}}

*Status:* I (der) think the notion of a context/mapping/properties table is possibly agreed but the details are not. RDFj's context is simple and appealing, however the range information would allow more complete round tripping (handling of typed literals and RDF lists) depending on other decisions.

== Specifying the mapping ==

In cases where the publisher (and, potentially the consumer for sophisticated consumers) wants to override the default mappings there should be a declarative format for defining the mapping.  This format should be expressed in RDF? JSON? ad hoc API parameters?

*Status:* Jeni proposes using RDF for this at least at the publisher end, Mark uses JSON when mapping the other way.

= JSON format issues ==

== Simple resource description ==

A single, simple resource should map to a simple JSON object with some property to designate it's URI. So:

{{{
  <http://www.w3.org/TR/rdf-syntax-grammar>
    dc:title "RDF/XML Syntax Specification (Revised)" .
}}}

maps to something like

{{{
  {
    "@": "http://www.w3.org/TR/rdf-syntax-grammar",
    "title": "RDF/XML Syntax Specification (Revised)"
  }
}}}

*Status:* Agreed but the naming of the property is open, candidates include `@`, `id`, `_about`.

== Property naming ==

Properties in the JSON should have short simple names.

In the absence of any explicit configuration the name should be the `rdfs:label` where available or the localName part of the URI. The publisher should be able to override these via a configuration.

This is underspecified. The implementation will have to cope with clashes, multiple labels, possibly name mangling to ensure the names are legal Javascript identifiers. However, so long as the translation is stable and recorded the implementations could chose to handle these differently?

*Status:* Agreed on principle, not necessarily deatils.

== bNodes - single reference ==

If the object of a triple is a bNode and there is no other reference to that bNode within the result set then the bNode should be encoded as a nested JSON object:

{{{
  <http://www.w3.org/TR/rdf-syntax-grammar>
    dc:title "RDF/XML Syntax Specification (Revised)" ;
    ex:editor [
      ex:fullName "Dave Beckett" ;
    ] .
}}}

maps to:

{{{
  {
    "@": "http://www.w3.org/TR/rdf-syntax-grammar",
    "title": "RDF/XML Syntax Specification (Revised)",
    "editor": {
      "fullName": "Dave Beckett",
    }
  } 
}}}

*Status:* Agreed?

== Resource references ==

When the object of a triple is a resource `http://example.com/foo` then the corresponding JSON encoding could be what?

 # `"http://example.com/foo"`  - Jeni
 # `"<http://example.com/foo>"` - RDFj
 # `"<foo>"`                   -  RDFj with `base` set in the context
 # `"someid"`                  - Exhibit where someid is the id of another object

Simple strings break round tripping, pointy-bracketed strings are arguably more surprising to target developers (and break round tripping in pathological cases), short form ID strings (similar to the abbreviation of properties) may be useful when referencing things like concepts in ontologies (e.g. `{ "type" : "Person" }`).

*Status:* Open

== Multi-valued properties ==

When there are multiple objects for the same subject/predicate they should map to JSON arrays:

{{{
   <http://example.com/r1>  eg:prop "foo", "bar", "baz" .
}}}

becomes

{{{
   {
      "@" : "http://example.com/r1",
      "prop" : [ "foo", "bar", "baz" ]
   }
}}}

When there are single values no array is used:

{{{
   <http://example.com/r1>  eg:prop "foo" .
}}}

becomes

{{{
   {
      "@" : "http://example.com/r1",
      "prop" : "foo"
   }
}}}
 
but the publisher can configure the API to always return an array to give consistency for the consumer. 

*Status:* Agreed that multiple values map into arrays and that single values should generally map onto simple values. Some discussion on whether the transition between the two is driven by the data (all uses of a given property in a given result set are consistent), by configuration or by the simple default.

== List-valued properties ==

RDF collections (aka lists) should also map into JSON arrays:
{{{
   <http://example.com/r1>  eg:prop ("foo" "bar" "baz") .
}}}

becomes

{{{
   {
      "@" : "http://example.com/r1",
      "prop" : [ "foo", "bar", "baz" ]
   }
}}}


This means that Lists do not round trip. There are various possible solutions to this.

*Status:* Agreed that this should be the mapping? 

Proposed that the mapping object could record sufficient information to allow round tripping in easy cases but that is not agreed yet:

{{{
   "properties" : [
       { "name" : "prop",
         "uri" : "http://example.com/ont#prop",
         "range" : "rdfs:List" }
   ]    
}}}

== Language tagged literals ==

Literals with a language tag such as:

{{{
  <http://statistics.data.gov.uk/id/local-authority-district/00PB>
    skos:prefLabel "The County Borough of Bridgend"@en ;
    skos:prefLabel "Pen-y-bont ar Ogwr"@cy ;
}}}

could be handled in different ways.

1. Use lexical encoding of rdf:PlainLiteral (dropping trailing `@` for simple strings with no lang tag).

{{{
{
  "@" : "http://statistics.data.gov.uk/id/local-authority-district/00PB"
  "prefLabel" : "The County Borough of Bridgend@en" ,
  "prefLabel" :  "Pen-y-bont ar Ogwr@cy" 
}
}}}

This is the RDFj approach and Mark points out that a JSON API could easily provide access to the value/lang parts of the string as if they were separate object fields.

2. Move the language encoding into the property name either by explicit mapping (based on some pattern language which matches on lang tags) or some generic mapping (Jeni).

{{{
{
  "@" : "http://statistics.data.gov.uk/id/local-authority-district/00PB"
  "prefLabel_en" : "The County Borough of Bridgend" ,
  "welshLabel" :  "Pen-y-bont ar Ogwr" 
}
}}}
 
3. Encode as a structured object.

*Status:* Under discussion.

== Typed literals - XSD types ==

Literals of type `xsd:decimal` (or its subtypes), `xsd:float` and `xsd:double` would all map to JSON integers.  This breaks round tripping though for properties that are used uniformly then the mapping table could include range information to enable inversion.

Literals of type xsd:dateTime might map to plain strings in RFC1123 format (for compatibility with Javascript's Date.parse) or could be handled as below.

Literals of other XSD types could be (1) just their lexical form as strings, (2) strings but with a range annotation in the mapping table, (3) strings in Turtle ^^ syntax, (4) structured objects.

*Status:* Numbers seem to be agreed, the rest are open.

== Typed literals - others ==

In some cases non-xsd data types are used to indicate the interpretation of values such as in:

{{{
  <http://statistics.data.gov.uk/id/local-authority-district/00PB>
    skos:notation "00PB"^^geo:StandardCode ;
    skos:notation "6405"^^transport:LocalAuthorityCode .
}}}

in those cases Jeni points out that as well as the above options we could also move the type information in the property name (analogous to one possible handling of lang tags):

{{{
  {
    "@": "http://statistics.data.gov.uk/id/local-authority-district/00PB",
    "onsCode": "00PB",
    "dftCode": "6405"
  }
}}}

*Status:* 

== Nesting resource references ==

In cases where the object of a property is a resource and that resource is also the subject of more triples in the results set there is a choice of whether to nest the JSON objects or flatten them.  So:

{{{
  <http://example.org/about>
    dc:title "Anna's Homepage"@en ;
    foaf:maker <http://example.org/anna> .

  <http://example.org/anna>
    foaf:name "Anna Wilder" ;
    foaf:homepage <http://example.org/about> .
}}}

could become:

{{{
  {
    "@": "http://example.org/about",
    "title": "Anna's Homepage",
    "maker": {
      "@": "http://example.org/anna",
      "name": "Anna Wilder",
      "homepage": "http://example.org/about"
    }
  }
}}}

or:

{{{
  {
    "@": "http://example.org/anna",
    "name": "Anna Wilder",
    "homepage": {
      "@": "http://example.org/about",
      "title": "Anna's Homepage",
      "maker": "http://example.org/anna"
    }
  } 
}}}

or:

{{{
  {
    "@": "http://example.org/anna",
    "name": "Anna Wilder",
    "homepage": "http://example.org/about"
  },
  {
    "@": "http://example.org/about",
    "title": "Anna's Homepage",
    "maker": "http://example.org/anna"
  }
}}}

In general there will be some non-tree graphs so nesting is not sufficient and in some cases clients will need to decide when to check up a URI link to see if it references to another resource in the results set. This interacts with [#Resource_references].

_Der comment_: RDF/XML has the same issues. Experience with Jena suggests that controlling which nestings to prefer for the most common cases is possible ([http://www.openjena.org/IO/iohowto.html#output pretty types]) but that there are always some applications that need a different nesting. Given our goals of simplicity I'm inclined to put everything at the top level, or only nest tree-structured references.

*Status:* open

== rdf:type shortcut ==

Do we want a shortcut for denoting the rdf:type of an object? Such as "a" instead of the plain "type" that would result from the rules so far?

== bNodes - graphs ==

bNodes referenced from more than one place need some form of ID (and then there's the same question of when to nest the JSON objects as above).

The question is what format should that ID take and how identifiable should it be?

RDFj uses `"<bnode:abc>"`. 

*Status:* open


== Named graphs? ==

It's not a goal of this work to support named graphs in results. Should it be?