#summary binding variables to values during a request

=Binding Variables=

Variables are used to alter the behaviour of specific components, e.g. to support paging and sorting, as well as to inject values into SPARQL queries. The API supports binding of variables from a number of different places including the API configuration and the request parameters.

Variables are bound based on (in order):

  # variable declarations at the API level
  # URI template matching
  # request parameter bindings
  # variable declarations at the endpoint level
  # the binding of the `item` variable within an item endpoint

A variable binding consists of a *variable name* and a *variable value* which may be any kind of RDF resource (including a typed literal).

Variables can be declared explicitly at either the API level or the endpoint level. Within the configuration, a variable binding is created using a `api:Variable` resource, which can have the properties `api:name`, `api:value` and `api:type`. The variable's value is determined by substituting any occurrences of `{varName}` within the value of the `api:value` with the value of the named variable from the existing set of variable bindings. It is possible for API-level or endpoint-level variables to depend on each other so long as this does not result in a circular dependency.

When the endpoint specifies a `api:uriTemplate`, the process of matching against the URI template creates some additional variable bindings, which override those specified at the API level. Within the endpoint path template, any path segments that are of the form `{varName}` create a variable binding with the name `varName` and a plain literal value that is the path segment from the request URI. Within the endpoint parameter templates, any endpoint parameter template values of the form `{varName}` create a variable binding with the name `varName` and a plain literal value that is the request parameter value from the request parameter whose name is the same as the endpoint parameter template name.

All unreserved request parameters (ie those that do not begin with an underscore) are mapped directly into variable bindings, and override any variable bindings specified at the API level or through matching against the URI template. These variables all have plain literal values.

In an item endpoint, the value of the `api:itemTemplate` property creates a variable binding with the name `item`. Its value is a resource whose URI is constructed by taking the value of the `api:itemTemplate` and replacing any `{varName}` within it with the string value of the named variable. Note that this `item` variable overrides any other binding of the `item` variable.

==Examples==

With the following configuration:

{{{
<http://education.data.gov.uk/api> a api:API
  ...
  api:variable [
    api:name "base" ;
    api:value "http://education.data.gov.uk/id" ;
  ], [
    api:name "areaBase" ;
    api:value "http://statistics.data.gov.uk/id" ;
  ], [
    api:name "england" ;
    api:value "{areaBase}/country/921" ;
    api:type rdfs:Resource ;
  ] ;
  ...
  api:endpoint [
    api:uriTemplate "school/{identifier}" ;
    api:itemTemplate "{base}/school/{identifier}" ;
    api:variable [
      api:name "school" ;
      api:value "{base}/school/{identifier}"
      api:type rdfs:Resource ;
    ], [
      api:name "schoolNumber" ;
      api:value "{identifier}" ;
      api:type xsd:integer ;
    ]
    ...
  ]
}}}

The request `doc/school/12345?localAuthority.code=00BX&_view=detailed` causes the following variable bindings:

  * `base = "http://education.data.gov.uk/id"`
  * `areaBase = "http://statistics.data.gov.uk/id"`
  * `england = <http://statistics.data.gov.uk/id/country/921>`
  * `identifier = "12345"`
  * `localAuthority.code = "00BX"`
  * `school = <http://education.data.gov.uk/id/school/12345>`
  * `schoolNumber = 12345`
  * `item = <http://education.data.gov.uk/id/school/12345>`
