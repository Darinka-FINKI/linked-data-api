#summary Linked Data API Specification

=Introduction=

This document defines a vocabulary and processing model for a configurable API layer intended to support the creation of simple RESTful APIs over RDF triple stores. 

The API layer is intended to be deployed as a proxy in front of a SPARQL endpoint to support:

  * Generation of documents (information resources) for the publishing of Linked Data
  * Provision of sophisticated querying and data extraction features, without the need for end-users to write SPARQL queries
  * Delivery of multiple output formats from these APIs, including a simple serialisation of RDF in JSON syntax

==Document Outline==

  * Overview of the goals and requirements
  * Detailed processing model & specification of behaviour for each of the key components
  * Vocabulary & Configuration

==Document Conventions==

The examples used in this document assume that the following namespaces have been defined, unless otherwise states

||rdf||`http://www.w3.org/1999/02/22-rdf-syntax-ns#`||
||rdfs||`http://www.w3.org/2000/01/rdf-schema#`||
||xsd||`http://www.w3.org/2001/XMLSchema#`||
||api||`TODO`||

API configuration examples use the Turtle syntax for readability in the specification. This is not meant to constrain the syntaxes supported by implementations.

==Rationale and Requirements==

Simple RESTful APIs are well supported and understood by a large community of web developers. Faced with Linked Data and SPARQL endpoints this community faces a steep learning curve before they are able to make use of the power provided by the underlying technologies. Put differently, SPARQL is a power tool whose sophistication is unnecessary for many users. 

There is scope for a standard way to provide simple RESTful APIs over RDF graphs to bridge the gap between Linked Data and SPARQL. This specification aims to fill that gap by defining an easy to use and easy to deploy API layer that can act as a proxy for any SPARQL endpoint. This proxy supports generation of:

  * Easy-to-process representations of resources (simple JSON, XML and CSV formats)
  * Easy-to-construct lists of resources based on various selection criteria

The goal is for the API layer to provide some basic functionality "out-of-the-box", but provide a range of configuration options to support additional, domain-specific customisation and functionality. 

The API layer may be deployed directly by the publisher of the SPARQL endpoint or may be deployed by a third-party, perhaps as a local proxy to a remote endpoint.

The following additional requirements have driven the creation of this specification:

  * The configuration syntax need to be simple, easy to author, and should support a "view source" approach to customising the API layer and the creation of new services. i.e. the configuration needs to be writable by hackers and understandable without the need for tool support
  * The configuration needs to be abstract enough to be easy, have enough depth to do the hard things. In practice this means that a simple declarative approach is supplemented by an "escape mechanism" allowing users to bind SPARQL queries directly to URLs
  * The API design should not force any particular URI pattern and be flexible to support a range of approaches and best practices. E.g `/doc/school/primary` or `/list/school/primary` should both be valid for defining a list of schools.
  * The API should support rendering to simple formats using content negotiation, suffixes and parameters, with depth and flexibility to support domain-specific or URI-specific views of data
  * The API should support both schema-less (all properties of a particular resource) and templated (lists of properties) views should be supported
  * Generation views containing lists of resources should be pageable
  * The APIs should provide a stepping stone to help publishers and developers get into linked data. E.g it should include things like URIs for resources, and reflect back SPARQL queries to allow developers to understand how a particular response was generated
  * The configuration should be extensible, allowing API providers and implementors to provide unique services. E.g. allowing users to carry out geographic searches or free-text searches within the APIs

Non-requirements are:

  * APIs do not have to support PUT/POST requests, this specification defines a read-only access layer over SPARQL endpoints
  * Not all results from the API will be available from the underlying SPARQL endpoint; best-practice documentation will encourage publishers to put any statements about non-information resources within the SPARQL endpoint

==Deployment Example==

The following examples provide an illustration of the range of access patterns that the API is intended to support. The example URIs are taken from the Edubase data published by the data.gov.uk project at `http://education.data.gov.uk/`:

  * `/doc/school/12345` should respond with a document that includes information about `/id/school/12345` (a "concise bounded description":http://www.w3.org/Submission/CBD/ of that resource)
  * `/doc/school` should return the first page of a list of schools in alphabetical order based on their name, including only the labels and types of those schools
  * `/doc/school?_page=2` should return the second page of results
  * `/doc/school?_view=detailed` should return a list of schools, including a certain (larger) set of properties of those schools
  * `/doc/school?_sort=size` should return a list of schools in ascending size order
  * `/doc/school?_sort=-size` should return a list of schools in descending size order
  * `/doc/school?_sort=-size,name` should return a list of schools sorted first in descending size, then by name
  * `/doc/school?type=primary` should return a list of primary schools
  * `/doc/school/primary` should be a shorthand for the above
  * `/doc/school?district.code=00BX` should return a list of schools in the administrative district whose `skos:notation` is `00BX`
  * `/doc/school/district/00BX` should be an alias for the above
  * `/doc/school?district.name=City+of+London` should return a list of schools in the administrative district whose `rdfs:label` is `City of London`
  * `/doc/school?search-district.name=London` should return a list of schools whose administrative district's name contains `London` (in API implementations that support free-text search)
  * `/doc/school?near-lat=0&near-long=0&distance=5` should return a list of schools within five miles of 0,0 (in API implementations that support geographic search)

For all of the above, it should be possible to use a suffix on the part of the URI prior to the search query to indicate the type of the response. For example:

  * `/doc/school.ttl?district.code=00BX` should return Turtle
  * `/doc/school.json?district.code=00BX` should return simple JSON
  * `/doc/school.rdf?district.code=00BX` should return RDF/XML
  * `/doc/school.xml?district.code=00BX` should return simple XML

_Note that the API layer will not carry out the `303 See Other` redirection from `/id/school/12345` to `/doc/school/12345`; it's expected that this will be done through a proxying layer above the API_

The API itself would be described at:

{{{http://education.data.gov.uk/api}}}

This would return the specification of the API (in various formats just as before), and API implementations may offer the ability to adjust the API through PUTting or POSTing to that URI.

The API specification for a particular list would be available at:

{{{http://education.data.gov.uk/api/doc/school}}}

Note that the structure of these URIs is API implementation dependent; we would require the result of a query on the API to include a pointer to the specification for the particular returned list. For example, at `/doc/school`:

{{{
{
  "format": "linked-data-api",
  "version": "0.1",
  "results": [
    "_about": "http://education.data.gov.uk/doc/school?page=0",
    "metadata": "http://education.data.gov.uk/api/doc/school",
    "partOf": "http://education.data.gov.uk/doc/school",
    "next": "http://education.data.gov.uk/doc/school?page=1",
    "first": "http://education.data.gov.uk/doc/school?page=0",
    "page": 0,
    "pageSize": 10,
    "contains": [{
      "_about" : "/id/school/12345" ,
      "name" : "St Johns School" ,
      "type" : [ "school", "primary" ]
    }, {
      ...
    }, ... ]
  ]
}
}}}

=Processing Model=

The API layer is intended to associate URLs with processing logic that will extract data from a SPARQL endpoint using one or more SPARQL queries and then serialize the results using the format requested by the client.

A URL may identify a single resource whose properties are to be retrieved. The URL may also identify a set of resources, either through structure of the URL or through query parameters.

This process can be summarised with the following steps:

  # *Identifying an Endpoint* -- the API receives a `GET` request made to a particular URI. This request is is mapped to an *Endpoint* that describes further processing logic
  # *Binding Variables* -- the API creates a number of variable bindings based on the structure and parameters of the incoming request, and the Endpoint configuration. These variables as well as the available API configuration and request metadata describe the *Context* for the execution.
  # *Selecting Resources* -- the API identifies a sequence of items who properties are to be returned. Usually this will be based on a *Selector* that describes how to identify a single item or an ordered list of resources, in concert with the available bindings 
  # *Viewing Resources* -- the API retrieves the desired properties of the identified resource, constructing an RDF graph of the results. This process is described by a *Viewer* that identifies the relevant properties of the resources.
  # *Formatting Graphs* -- the API identifies how to serialize the resulting RDF graph to the client. This process is defined by a *Formatter*

The following sections describe each of these steps in more detail.

==Identifying an Endpoint==

Incoming requests to the API layer must be mapped through to an *Endpoint* that describes further processing of the request. 

An Endpoint will have:

  * A URI Template that identifies the set of URLs to which it should respond
  * Optionally, a Item Template that describes how to construct a URI for delivery of Linked Data
  * Optionally, a set of Variables that will be added to the Context during processing
  * A Selector that describes how to retrieve a list of resources from the configured SPARQL Endpoint
  * A set of named Viewers that describe specific sets of properties to retrieve about each resource
  * A list of named Formatters that define the possible representation formats that can be delivered to a client.

The identification of the Endpoint to use to service a request involves testing the URI Templates associated with all of the configured Endpoints against the structure of the incoming request. 

===Detailed Processing===

When a request is made, the query part of the request URI is split off to create a set of *request parameter bindings*.

The `api:base` property of the API is then stripped from the start of the request URI to give a *request path*. If the API has no `api:base` property then the authority (server name) is stripped from the request URI.

If the last segment in the request path ends in an extension which names a known formatter, this extension is stripped from the request path. See the section on Formatting Graphs below for more details.

The endpoints associated with the API can be identified through the `api:endpoint` property. The path is matched against an endpoint as follows:

  # if the request path and parameter bindings match the `api:uriTemplate` of an endpoint, that endpoint is used; it is implementation defined which endpoint is used if there is more than one whose `api:uriTemplate` matches
  # otherwise, the API returns a `404 Not Found`

To determine whether a `api:uriTemplate` matches the request, the `api:uriTemplate` should first be processed to create an *endpoint path template* and a set of *endpoint parameter templates*. The endpoint path template matches the request path if the request path matches a regular expression formed by replacing any occurrences of `{varName}` within the request path template with `([^/]+)`. The endpoint parameter templates match the request parameter bindings if every endpoint parameter template matches a request parameter binding. An endpoint parameter template matches a request parameter binding if the names are the same and either the values are the same or the value of the endpoint parameter template looks like `{varName}`.

_Note: This testing between endpoint parameter templates and request parameter bindings does not take into account any typing. The values must exactly match for the endpoint to be a match to the request._

===Examples===

The request URI:

<pre>http://education.data.gov.uk/doc/school/localAuthority/00BX?type=primary</pre>

would match the URI templates:

{{{
doc/school/localAuthority/{code}
doc/school/localAuthority/{code}?type={type}
doc/school/localAuthority/{code}?type=primary
doc/school/{concept}/{code}
}}}

It would not match:

{{{
doc/school/localAuthority/{code}?boarding=true
doc/school/{identifier}
}}}

===Binding Variables===

Variables are used to alter the behaviour of specific components, e.g. to support paging and sorting, as well as to inject values into SPARQL queries. The API supports binding of variables from a number of different places including the API configuration and the request parameters.

Variables are bound based on (in order):

  # variable declarations at the API level
  # URI template matching
  # request parameter bindings
  # variable declarations at the endpoint level
  # the binding of the `item` variable within an item endpoint

A variable binding consists of a *variable name* and a *variable value* which may be any kind of RDF resource (including a typed literal).

Variables can be declared explicitly at either the API level or the endpoint level. Within the configuration, a variable binding is created using a `api:Variable` resource, which can have the properties `api:name`, `api:value` and `api:type`. The variable's value is determined by substituting any occurrences of `{varName}` within the value of the `api:value` with the value of the named variable from the existing set of variable bindings. It is possible for API-level or endpoint-level variables to depend on each other so long as this does not result in a circular dependency.

When the endpoint specifies a `api:uriTemplate`, the process of matching against the URI template creates some additional variable bindings, which override those specified at the API level. Within the endpoint path template, any path segments that are of the form `{varName}` create a variable binding with the name `varName` and a plain literal value that is the path segment from the request URI. Within the endpoint parameter templates, any endpoint parameter template values of the form `{varName}` create a variable binding with the name `varName` and a plain literal value that is the request parameter value from the request parameter whose name is the same as the endpoint parameter template name.

All unreserved request parameters (ie those that do not begin with an underscore) are mapped directly into variable bindings, and override any variable bindings specified at the API level or through matching against the URI template. These variables all have plain literal values.

In an item endpoint, the value of the `api:itemTemplate` property creates a variable binding with the name `item`. Its value is a resource whose URI is constructed by taking the value of the `api:itemTemplate` and replacing any `{varName}` within it with the string value of the named variable. Note that this `item` variable overrides any other binding of the `item` variable.

===Examples===

With the following configuration:

{{{
<http://education.data.gov.uk/api> a api:API
  ...
  api:variable [
    api:name "base" ;
    api:value "http://education.data.gov.uk/id" ;
  ], [
    api:name "areaBase" ;
    api:value "http://statistics.data.gov.uk/id" ;
  ], [
    api:name "england" ;
    api:value "{areaBase}/country/921" ;
    api:type rdfs:Resource ;
  ] ;
  ...
  api:endpoint [
    api:uriTemplate "school/{identifier}" ;
    api:itemTemplate "{base}/school/{identifier}" ;
    api:variable [
      api:name "school" ;
      api:value "{base}/school/{identifier}"
      api:type rdfs:Resource ;
    ], [
      api:name "schoolNumber" ;
      api:value "{identifier}" ;
      api:type xsd:integer ;
    ]
    ...
  ]
}}}

The request `doc/school/12345?localAuthority.code=00BX&_view=detailed` causes the following variable bindings:

  * `base = "http://education.data.gov.uk/id"`
  * `areaBase = "http://statistics.data.gov.uk/id"`
  * `england = <http://statistics.data.gov.uk/id/country/921>`
  * `identifier = "12345"`
  * `localAuthority.code = "00BX"`
  * `school = <http://education.data.gov.uk/id/school/12345>`
  * `schoolNumber = 12345`
  * `item = <http://education.data.gov.uk/id/school/12345>`

==Selecting Resources==

Having identified an Endpoint and having identified and bound all the in-scope variables, the next processing step is to select zero or more resources from the SPARQL endpoint. These resources will act as input to further processing steps (Viewing and Formatting).

There are two different types of Endpoint:

  * An *Item Endpoint* selects a single resource which is identified by the in-scope `item` variable. This is typically generated using an Item Template.
  * A *List Endpoint* selects zero or more resources based on a query made to the configured SPARQL endpoint. 

For List Endpoints the query to be executed may be explicitly defined or assembled based on a declarative description of the desired behaviour. In both cases the following aspects of query are always automatically constructed:

  * the set of namespace prefixes, which is the same as those in the configuration file (or the in-scope prefixes if the configuration is not loaded from a file)
  * the LIMIT and OFFSET clauses, to support automatic paging

The query itself is a [http://www.w3.org/TR/rdf-sparql-query/#select SELECT query] based on a combination of the request parameters and the *selector* associated with the endpoint through the `api:selector` property. The query can be specified directly or constructed automatically.

Paginated is supported by adding an OFFSET clause based on the `_page` request parameter, if present (otherwise no OFFSET clause is added) and a LIMIT clause with the value:

  * of the `api:maxPageSize` of the API if the `_pageSize` parameter is present and exceeds that value
  * otherwise, the `_pageSize` request parameter, if present
  * otherwise, the `api:defaultPageSize` property of the endpoint, if present
  * otherwise, the `api:defaultPageSize` property of the API, if present
  * otherwise, 10

===Selection Based on Explicit Query===

A query may be explicitly defined using:

  * a `_select` request parameter, if present
  * otherwise, a `api:select` property of the selector

Both of these must contain a SELECT query, including the SELECT clause itself.

In this case, the variable bindings are used to replace SPARQL variable references within the pattern (any `?varName`) with one of:

  * `<varValue>` if the variable is of type rdfs:Resource or
  * `"varValue"^^varType` if the variable is of a specific datatype or
  * `"varValue"@varLang` if the variable has a specific language or
  * `"varValue"` if the variable is a plain literal

Note that this may leave some variables within the SPARQL query; that's fine.

===Selection Based on a Constructed Query===

If the query is not specified directly it is constructed in two parts: the filtering of resources and the ordering of those resources. The final SELECT query used to construct the list of resources is constructed as:

{{{
SELECT ?item
WHERE {
  filter
}
ORDER BY order
}}}

Note that the order specification may also involve adding filters to the WHERE clause.

====Filters====

Resources are filtered based on a [http://www.w3.org/TR/rdf-sparql-query/#rGroupGraphPattern GroupGraphPattern] constructed by combining:

  * the `_where` request parameter
  * the unreserved request parameters (those that don't start with an underscore)
  * the `api:where` property of the selector
  * the `api:filter` property of the selector
  * the filters specified by the ancestors of the selector, as identified through the `api:parent` property; implementations should issue a warning if the parent selects its items through an explicit query as opposed to using filters

If none of these are present, the GroupGraphPattern is `{ ?item ?property ?value }`. If several are present, they are combined (this includes filters specified through `api:where` and `api:filter`).

The GroupGraphPattern must contain a binding for the `?item` variable. This indicates the items that are selected.

The `_where` and `api:where` properties hold SPARQL syntax directly, and can be simply concatentated into the GroupGraphPattern. Variable bindings are replaced as described above for the `api:select` property.

The `api:filter` property should be turned into a set of parameter bindings as if it were a URI query string. Any values that follow the pattern `{varName}` should be replaced by the value of that variable.

The set of parameter bindings from the `api:filter` should be combined with the unreserved request parameters. Where both sets contain the same parameter binding, the one from the request parameters should override the one from the `api:filter`.

This set of parameter bindings should be converted into something matching [http://www.w3.org/TR/rdf-sparql-query/#rTriplesSameSubject TriplesSameSubject]. The subject is `?item`.

For each parameter binding, the name should be mapped to a list of properties by 

  # removing the prefix `min-`, `max-`, `minEx-`, `maxEx-`, `name-` or `exists-`
  # splitting it on dots
  # mapping each part to a property

It is an error if any of the parts cannot be mapped to a property. The API should return a `400 Bad Request` error if the parameter binding came from a request parameter, and a `500 Internal Server Error` if it was present in the configuration.

The value should be mapped to an object. The type of the object is determined by the type of the parameter and the range of the final property in the list, as follows:

  * `<varValue>` if the parameter is of type rdfs:Resource or
  * `"varValue"^^varType` if the parameter is of a specific datatype or
  * `"varValue"@varLang` if the parameter has a specific language or
  * `<resource>` if the final property has a specified range that isn't a rdfs:Literal and there is a known resource whose short name (for example indicated through `api:label`) is the variable value or
  * `"varValue"^^varType` if the final property has a range of a specific datatype or
  * `"varValue"` otherwise

The query can then be constructed by creating a property list for each parameter binding. This is done as follows. In the case of a degenerate chain of a single property the triple pattern is:

{{{?item {property} {value} .}}}

where `{value}` is as described above. In the case of a chain longer than one then a series of patterns of the form:

{{{
?item {property 0} ?{var 0} .
...
?{var i-1} {property i} ?{var i} .
...
?{var n} {property n} {value} .
}}}

Where each `{var i}` is a newly allocated variable name, distinct from
other variables in the query. Implementations are free to translate this flat chain into equivalent SPARQL queries through use of blank nodes.

For example, say there is a parameter binding with the name `localAuthority.code` and value `00BX`. The name is split into `localAuthority` and `code` and these are mapped on to the properties `sch:localAuthority` and `skos:notation`. The resulting SPARQL is:

{{{
?item sch:localAuthority ?x1.
?x1  skos:notation "00BX" .
}}}

or, equivalently

{{{
?item sch:localAuthority [ skos:notation "00BX" ] .
}}}

If the original parameter binding had a recognised prefix, however, rather than specifying the object as part of the pattern directly, the object should be bound to a parameter which is then tested with a FILTER clause. The FILTER clause depends on the prefix used (in the following `?value` is the variable used to bind to the value of the property, and `object` is the object derived from the value in the parameter binding):

  * `min-` indicates `FILTER (?value >= object)`
  * `max-` indicates `FILTER (?value <= object)`
  * `minEx-` indicates `FILTER (?value > object)`
  * `maxEx-` indicates `FILTER (?value < object)`
  * `name-` indicates `object rdfs:label ?value .`

A prefix of `exists-` is a special case that involves further changes to the pattern, depending o its value:

  * `true` -- no further change to the pattern is required. Will ensure that the property exists, regardless of value
  * `false` -- the pattern should be wrapped in an OPTIONAL clause and followed by a `FILTER (!bound(?value))` expression to negate the match

====Ordering====

The ordering of resources is based on a [http://www.w3.org/TR/rdf-sparql-query/#rOrderClause ORDER BY clause]. The clause is created using:

  * the `_orderBy` request parameter, if present
  * otherwise, the `_sort` request parameter, if present
  * otherwise, the `api:orderBy` property of the selector, if present
  * otherwise, the `api:sort` property of the selector, if present
  * otherwise, the ordering specified by the selector indicated by the `api:parent` property of the selector, if present; implementations should issue a warning if the parent orders its items through an explicit query as opposed to using a separate ordering specification
  * otherwise no ORDER BY is applied

The `_orderBy` request parameter and `api:orderBy` property contain space-separated [http://www.w3.org/TR/rdf-sparql-query/#rOrderCondition OrderConditions] which are turned into an ORDER BY clause simply by prepending `ORDER BY `. Note that this can only practically be used with `_where` and `api:where` since the variable bindings from the WHERE clause must be known for the ordering to be specified.

The `_sort` request parameter and `api:sort` property contain a sort specification which can be converted into a sequence of OrderConditions by first splitting the string based on commas and then, for each one:

  # removing any leading hyphen, which indicates a descending search
  # mapping the property path onto a list of properties; it is an error if this cannot be done (a `400 Bad Request` if the sort specification was request parameter, a `500 Internal Server Error` if it originated in the configuration file)
  # if one is not already present, adding a pattern within the WHERE clause based on that property list, with a variable as the object
  # creating an OrderCondition that references that variable, in the form `DESC(?varName)` if the sort specification started with a hyphen; if the range of the last property in the property list is a recognised XML Schema datatype, the relevant cast should be added

_Note: Sort specifications can be safely dropped if their values have already been fixed within the WHERE clause._

For example, start with the sort specification `-rating,sell.price`. Say that `rating` mapped on to `eg:rating`, `sell` onto `eg:sellingAt` and price onto `eg:price`, that `eg:rating` had a range of `xsd:integer` and `eg:price` had a range of `xsd:decimal`. In that case, the following would be added to the filter:

{{{
?item
  eg:rating ?rating ;
  eg:sellingAt [ eg:price ?price ] .
}}}

and the ORDER BY clause would look like:

{{{
ORDER BY DESC(xsd:integer(?rating)) xsd:decimal(?price)
}}}

_der: Why the explicit coercion?  If the range of eg:rating and eg:price is as you state then just need `ORDER BY DESC(?rating) ?price` surely?_

==Viewing Resources==

Having selected the resources of interest, some or all of the properties of those resources must be retrieved from the configured SPARQL endpoint to construct an RDF graph. This is done by selecting a *Viewer* that is used to construct an RDF graph for each item in the sequence. The relevant viewer is selected as follows:

  * if there is a `_view` request parameter, then matching that to the `api:name` of a viewer that is specified through the `api:viewer` property on the endpoint or the `api:viewer` property on the API. If the `_view` request parameter is present, but there is no viewer with that name, the result is a `400 Bad Request` error.
  * otherwise, if the endpoint has a `api:defaultViewer` property, the viewer specified by that property
  * otherwise, if the API has a `api:defaultViewer` property, the viewer specified by that property
  * otherwise, the `api:describeViewer` viewer, which is built in

The API supports a set of built-in viewers and also the ability to create specialised, custom viewers to support specific use cases.

===Built-in Viewers===

The following viewers are built in to the API.

`api:describeViewer` is named "description" and returns a graph that is exactly what is returned by a DESCRIBE query for the item on the SPARQL endpoint. How the SPARQL endpoint implements DESCRIBE will determine exactly what is returned (it may be a concise bounded description, for example).

`api:labelledDescribeViewer` is named "all" and returns a graph that is whatever is returned by a DESCRIBE query for the item on the SPARQL endpoint, supplemented by `rdfs:label` properties for all referenced resources. Again, the precise details of what's returned will depend on the SPARQL endpoint.

`api:basicViewer` is named "basic" and returns a graph that includes just the `rdfs:label` and `rdf:type` of each item. This is equivalent to:

{{{
api:basicViewer a api:Viewer ;
  api:name "basic" ;
  api:property rdfs:label, rdf:type .
}}}

===Specialised Viewers===

Specialised viewers need to create a graph for each item.

_JT: Did we resolve whether this was done through a CONSTRUCT query or through a DESCRIBE followed by a filtering of properties?_

_der: Not sure if we definitely resolved it but I think it has to be the latter due to the handling of bNodes._

A viewer may include other viewers through its `api:include` property. In that case, the graph will include the properties specified by the included viewers as well as those specified locally on the viewer itself.

The graph can be constructed explicitly using SPARQL syntax (specifically  [http://www.w3.org/TR/rdf-sparql-query/#rConstructTriples ConstructTriples]) within:

  * the `_template` request parameter or
  * the `api:template` property on the viewer

If neither of these are specified, the viewer must specify the properties that are included in the graph for each item, and the properties of the resources that these items reference and so on. In other words, a viewer needs to specify a set of property chains.

The set of property chains is constructed by combining:

  * the property chains specified in the `_properties` request parameter
  * the property chains specified in the `api:properties` property of the viewer
  * the property chains specified in the `api:property` property of the viewer

The `api:property` property should point to either individual instances of `rdf:Property` or `rdf:List`s whose items are all instances of `rdf:Property`.

Similar `rdf:List`s can be created from the value of the `_properties` request parameter or `api:properties` property. These are created by first splitting the value based on commas. The individual values should be property paths. These property paths can be split on dots, each short property name mapped to an `rdf:Property`, and these used to create a list of properties.

Each property chain can be used to identify a particular property within the graph by navigating from the selected item through the properties in the chain. All triples en route to the final property are included, even if there is no final property. For example, given the source graph:

{{{
<http://education.data.gov.uk/id/school/12345>
  a sch:School ;
  sch:localAuthority <http://statistics.data.gov.uk/id/local-authority/00BX> .

<http://statistics.data.gov.uk/id/local-authority/00BX>
  a admin:UnitaryAuthority ;
  rdfs:label "Knowsley Borough Council"@en ;
  admin:area <http://statistics.data.gov.uk/id/local-authority-area/00BX> .

<http://statistics.data.gov.uk/id/local-authority-area/00BX>
  a admin:UnitaryAuthorityArea ;
  rdfs:label "Knowsley"@en ;
  admin:country <http://statistics.data.gov.uk/id/country/921> .

<http://statistics.data.gov.uk/id/country/921>
  a admin:Country ;
  rdfs:label "England"@en .
}}}

Where the school is the item, the property chains:

{{{
(rdf:type)
(sch:localAuthority admin:area rdfs:label)
(sch:localAuthority admin:area admin:country stats:population)
}}}

would result in the graph:

{{{
<http://education.data.gov.uk/id/school/12345>
  a sch:School ;
  sch:localAuthority <http://statistics.data.gov.uk/id/local-authority/00BX> .

<http://statistics.data.gov.uk/id/local-authority/00BX>
  admin:area <http://statistics.data.gov.uk/id/local-authority-area/00BX> .

<http://statistics.data.gov.uk/id/local-authority-area/00BX>
  rdfs:label "Knowsley"@en ;
  admin:country <http://statistics.data.gov.uk/id/country/921> .
}}}

which includes the `admin:country` property of the local authority area despite the source graph not including the `stats:population` property for the country.

===Additional Graph Metadata===

In addition to the graph that is generated about the items in the list, extra information is included about the graph itself, and the formats that it is available in.

For an item endpoint, this metadata should include:

  * a `foaf:primaryTopic` link from the request URI to the item
  * a `foaf:isPrimaryTopicOf` link from the item to the request URI

For a list endpoint, this metadata should include statements about:

  * the list that's being viewed, whose URI is the same as the request URI after removing the `_page` URI parameter, if there is one
  * the page that's being viewed, whose URI is the same as the request URI, with the `_page` parameter set to the current page

The statements should include:

  * a `rdf:type` statement stating that the list is an `api:List`
  * a `rdf:type` statement stating that the page is an `api:Page`
  * `dct:hasPart`/`dct:isPartOf` links from the list to the page and the reverse
  * a `xhv:first` link from the page to the first page
  * a `xhv:last` link from the page to the last page if this is identifiable
  * a `xhv:next` link from the page to the next page
  * a `xhv:prev` link from the page to the previous page
  * a `openSearch:itemsPerPage` property on the page indicating the LIMIT used to select the items
  * a `openSearch:startIndex` property on the page indicating the OFFSET used to select the items
  * a `api:items` link from the page to a `rdf:List` containing the items, in order

Both item and list endpoints should include the following statements for the page:

  * a `api:metadata` link from the page to the URI for the endpoint specification
  * `dct:hasVersion`/`dct:isVersionOf` links to/from URIs that will provide different views of the selected items (ie with different values of the `_view` parameter)
  * `dct:hasFormat`/`dct:isFormatOf` links to/from URIs that specify the different formats of the page, using either a suffix on the URI or a `_format` URI parameter, depending on the `api:contentNegotiation` property on the API

The different versions (views) of the page should each have a `rdfs:label` which is the `api:name` of the view.

The different formats of the page should each have a `rdfs:label` which is the `api:name` of the format, and a `dct:format` which is a blank node whose `rdfs:label` is the `api:mimeType` of the format.

The graph should also include:

  * statements from the SPARQL endpoint about the list or page, including a full description of the objects of such statements
  * statements from the configuration about the list or page, including a full descriptions of the objects of such statements
  * statements within a named graph accessible at the SPARQL endpoint whose URI is the same as the item (when viewing a single item), list or page

==Formatting Graphs==

The representation that is finally returned for a request is determined by a formatter. A list of possible formatters is constructed from:

  * the built-in formatters supported by the implementation
  * the `api:defaultFormatter` property on the API
  * the `api:formatter` property on the API
  * the `api:defaultFormatter` property on the selected endpoint
  * the `api:formatter` property on the selected endpoint

If two formatters have the same name (indicated by `api:name`) then the one from lower in the list overrides the one from higher in the list. For example, a `'json'` formatter defined on an endpoint will override the built-in `'json'` formatter.

The formatter that is used is determined as follows:

  * if the `_format` request parameter is specified, and the API's `api:contentNegotiation` property is `api:parameterBased`, the formatter named in that parameter. If there is no such formatter, a `400 Bad Request` response is given.

_der: Is the `api:contentNegotiation` necessary? Why not just allow dot and `_format` notation freely?_

_JT: What if they clash? Which takes precedence? Or you do get a 400 error if that happens?_

  * otherwise, if the last path segment in the request URI uses an extension, such as `.ttl`, the formatter name is the one given after the final dot in that path segment. If there is no such formatter, continue (note that in this case the suffix will not be stripped from the request path prior to matching against endpoint URIs).
  * otherwise, use the `Accept` header in the request to perform content negotiation based on the `api:mimeType` properties of the available formatters _(JT: This is under-specified at the moment: if there are multiple formatters that match the Accept header, which gets used?)_
  * otherwise, if the endpoint contains a `api:defaultFormatter`, use that
  * otherwise, if the API contains a `api:defaultFormatter`, use that
  * otherwise use the `api:jsonFormatter`

The formatter itself is passed:

  * the RDF graph constructed by the viewer
  * the root resource in the graph: in the case of an item endpoint, this is the item itself; in the case of a list endpoint, it is the current page
  * the variable bindings, as described above
  * the prefix bindings present within the configuration file

There are five types of built-in formatter, with the `api:XsltFormatter` providing flexibility for programmatic addition of different formats as required:

  * `api:RdfXmlFormatter` instances are formatters that generate RDF/XML
  * `api:TurtleFormatter` instances are formatters that generate Turtle
  * `api:JsonFormatter` instances are formatters that generate simple JSON
  * `api:XmlFormatter` instances are formatters that generate simple XML
  * `api:XsltFormatter` instances are formatters that use XSLT stylesheets to format the results

Implementations must support `api:RdfXmlFormatter`s and `api:JsonFormatter`s. Support for the other formatter types is optional. Implementations may support other formatter types, or support additional configuration of the built-in formatter types through implementation-specific properties as long as their basic behaviours remain unchanged.

===RDF/XML Formatting===

RDF/XML formatters should create [http://www.w3.org/TR/rdf-syntax-grammar/ RDF/XML]. They should use the prefix bindings that they are passed as namespace declarations within the RDF/XML.

===Turtle Formatting===

Turtle formatters should create [http://www.w3.org/TeamSubmission/turtle/ Turtle]. They should use the prefix bindings that they are passed as prefix declarations within the Turtle.

===JSON Formatting===

The JSON formatter creates a simple JSON format based on the RDF graph that it's given.

The result is a single object, that looks like:

{{{
{
  "format": "linked-data-api" ;
  "version": "0.2" ;
  "result": {
    ...
  }
}
}}}

_der: The current implementation also includes the "context" property which provides the name/uri mapping and inferred type information for every property. See GoogleCode. This enables round tripping for well-behaved RDF. While round tripping is a non-goal at this stage we-Epimorphics need a simple update version of the protocol and including the context enables that. As a side effect the context also means that all the available properties are communicated to the client._

_JT: The disadvantage is that it can add a huge amount of weight to the JSON representation, at least in its current form. Putting the information at the metadata endpoint makes it accessible (for the purposes of round-tripping) without having the repetitive burden in every single document._

The resource described in the `result` property is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto JSON objects as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the object is given a `_id` property that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the object is given a `_about` property that contains the URI of the resource

The RDF properties of a resource are mapped onto JSON properties. The name of the JSON property is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The value of the JSON property is an array if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto a JSON value as follows:

  * if the `api:structured` property of the RDF property has the value `true` then the value is represented as an object with a `_value` property holding the value itself, and `_lang` or `_datatype` properties holding the language code and the short name of the datatype as applicable
  * otherwise, if the value has a datatype of `xsd:boolean`, it becomes `true` or `false`
  * otherwise, if the value has a numeric datatype (one of the XML Schema numeric datatypes), it becomes a number in the JSON
  * otherwise, if the value has the datatype `xsd:dateTime` it is mapped to a string in the date/time format recognised by `Date.parse`, namely `EEE, d MMM yyyy HH:mm:ss 'GMT'Z`
  * otherwise, if the value has the datatype `xsd:date` it is mapped to a string in the date format recognised by `Date.parse`, namely `yyyy-MM-dd`
  * otherwise, if the value is a `rdf:List`, it is mapped to an array whose items are the result of mapping the members of the list to JSON
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto a JSON object as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto a JSON object with no properties
  * otherwise, if the value is a resource it is mapped onto a string whose value is the URI of the resource
  * otherwise, if the JSON property is an array (because the RDF property has multiple values or is marked as multi-valued) then the value is represented as a string; if the value has a language then `@{lang}` is appended to the string; if the value has a datatype then `^^{datatype}` is appended to the string
  * otherwise (the value is a literal that isn't a boolean or number), it is mapped onto a string

===XML Formatting===

The XML formatter creates an XML representation that is very similar to the JSON representation. The outermost object is a `<result>` element with `format` and `version` attributes.

The resource described in the `<result>` element is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto XML elements as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the element is given a `id` attribute that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the element is given an `href` attribute that contains the URI of the resource

The RDF properties of a resource are mapped onto XML elements. The name of the XML element is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The contents of the XML element is a sequence of `<list>` elements if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto some XML content as follows:

  * if the value is a literal, it is mapped to a text node holding the value itself; `lang` or `datatype` attributes on the element hold the language code and the short name of the datatype as applicable
  * otherwise, if the value is a `rdf:List`, it is mapped to a sequence of `<item>` elements, one representing each of the results of mapping the members of the list to XML
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto an XML element as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto an empty XML element (with an `id` attribute if it it referenced more than once)
  * otherwise, if the value is a resource the element is given an `href` attribute whose value is the URI of the resource

===XSLT Formatting===

XSLT formatters create representations by taking the simple XML generated by the default XML formatter (`api:xmlFormatter`) and transforming it using the stylesheet specified by the `api:stylesheet` property of the XSLT formatter.

The XSLT stylesheet is passed an `$api:namespaces` parameter which contains an XML document in the format:

{{{
<namespaces>
  <namespace prefix="{prefix}">{value}</namespace>
  ... other namespaces ...
</namespaces>
}}}

It is also passed a parameter for each of the variable bindings, with the name equal to the variable name and the value being the string value of the variable.

=Property Paths=

Throughout the API specification and within URIs, *property paths* can be used to point to values within the data. The syntax of a property path is:

{{{
propertyPath := property ('.' propertyPath)*
property     := [a-zA-Z][a-zA-Z0-9_]*
}}}

_Note: Properties are constrained here to match the constraints on Javascript properties, to make the JSON easier to use. These restrictions also make it easier to use the property names within URIs._

For a property name used in a property path to be recognised, the API must have a mapping between the property name and the equivalent RDF property URI. Only properties for which this has been configured within the API will be recognised by the API (when it comes to specifying selectors and viewers; short names for all properties are supported when a full description of a resource is requested).

A property name is configured within the API by describing the property within the API specification itself or by pointing to an external ontology in which the property is described using the `api:vocabulary` property of the `api:API`.

If a property description is available, the property name will be (in order of priority):

  * the `api:label` of the property
  * the `rdfs:label` of the property
  * the local name of the property (the part after the last hash or slash)

If none of these match the _property_ production above, the property does not have a name suitable for querying in the API.

=Query Parameters=

Query parameters can be used to:

  * change what items appear in a list (the selector)
  * change what properties are listed for each item (the viewer)
  * change the way the list is serialised (the formatter)
  * provide default bindings for executed SPARQL queries

The `query` parameter can be used to create an arbitrary graph (based on a SPARQL query) which is serialised in the normal way. To simplify matters, this SPARQL query:

  * automatically includes namespace bindings that are defined globally within the API
  * automatically supports pagination features through the addition of `LIMIT` and `OFFSET` (_JT: I'm assuming we want to do this, but perhaps not_)

==Selecting==

Parameters can be used to specify properties to select items on:

  * `param=value` - resources whose `param` has the specified `value`
  * `min-param=value` - resources whose `param` is greater than or equal to the specified `value`
  * `max-param=value` - resources whose `param` is less than or equal to the specified `value`
  * `minEx-param=value` - resources whose `param` is greater than the specified `value`
  * `maxEx-param=value` - resources whose `param` is less than the specified `value`
  * `exists-param=(true|false)` - resources that do or do not have a value specified for `param`

_JT: how do we describe free text and geographic searches in these terms?_

In each of these cases, `param` may be a property path as described above.

Multiple specifications of the same parameter indicate a union. Intersection and negation can only be done through escaping to SPARQL (through `_where` or `_query`).

In addition, we define the following built-in query parameters:

  * `_page` is a number; the page that should be viewed
  * `_pageSize` is a number; the number of items per page
  * `_sort` is a comma-separated list of property paths to values that should be sorted on. A `-` prefix on a property path indicates a descending search
  * `_where` is a "GroupGraphPattern":http://www.w3.org/TR/rdf-sparql-query/#GroupPatterns (without the wrapping `{}`s)
  * `_orderBy` is a space-separated list of [http://www.w3.org/TR/rdf-sparql-query/#rOrderCondition OrderConditions]
  * `_select` is a [http://www.w3.org/TR/rdf-sparql-query/#select SELECT query]

===Examples===

Let us say that `/doc/school` has been configured to return all schools.

We can find all primary schools (schools whose type is 'primary') with:

{{{
/doc/school?type=primary
}}}

We can find all schools whose size is greater than 300 with:

{{{
/doc/school?min-size=300
}}}

We can find all primary schools with over 300 pupils with:

{{{
/doc/school?type=primary&min-size=300
}}}

We can find all primary and secondary schools with:

{{{
/doc/school?type=primary&type=secondary
}}}

We can find all schools in the local authority whose name is 'Surrey' with:

{{{
/doc/school?localAuthority.name=Surrey
}}}

==Viewing==

We define the following built-in parameters:

  * `_view` is the name of a viewer associated with the URI
  * `_properties` is a comma-separated list of property paths that should be included in the description of the resources in the list

===Examples===

We can access a more detailed view of the schools (as defined by the API) with:

{{{
/doc/school?_view=detailed
}}}

We can view the name of the school, its district, district code and district name with:

{{{
/doc/school?_properties=name,district.code,district.name
}}}

==Formatting==

We define the following built-in parameter:

  * `_format` is the name of a format associated with the URI that is used to format it

When an XSLT-based rendering is used, all parameters that are specified within the URI or defined within the API specification are passed to the XSLT stylesheet.

=Vocabulary & Configuration=

The linked data API middleware will work "out of the box", but it will usually need to be configured to get it to provide the API that the publisher requires. The configuration is expressed as RDF. This section defines the classes and properties that are used in that RDF and their effect on the behaviour of the implementation.

bq. Note that this RDF model is deliberately designed to make it easy to create a simple JSON representation of the RDF in which everything is nested within the API.

This specification does not define how the configuration should be supplied to an API implementation. The expectation is that configuration will be provided as a file, but implementations are free to support other options.

==API==

The `api:API` class defines the API as a whole. It has the following properties:

  * `api:sparqlEndpoint` is the SPARQL endpoint from which the API retrieves the data it exposes. Every API must indicate a single SPARQL endpoint.
  * `api:base` is the base URI for the API
  * `api:contentNegotiation` points to either `api:suffix` or `api:parameter`.  If it points to `api:suffix` this indicates that the extension on the last segment of the path within the request URI should be used to determine the formatter that is used. If it points to `api:parameter` this indicates that the `_format` parameter should be used to determine the formatter that is used. If there is no `api:contentNegotiation` property for the API, the implementation should assume `api:suffix`.
  * `api:maxPageSize` is the maximum size of lists returned by the API
  * `api:defaultPageSize` is the default size of lists returned by the API (which may be overridden by an endpoint or in a particular request by the `_pageSize` request parameter)
  * `api:vocabulary` points to any RDF that contains the definitions of resources such as properties and classes that may be referenced with a short name
  * `api:variable` holds any variables that are defined throughout the API and available within the specifications of all endpoints
  * `api:endpoint` holds the `api:Endpoint`s that the API exposes

===Examples===

{{{
<http://education.data.gov.uk/api> a api:API ;
  api:sparqlEndpoint <http://services.data.gov.uk/education/sparql> ;
  api:base "http://education.data.gov.uk/doc/" ;
  api:contentNegotiation api:suffix ;
  api:vocabulary "http://education.data.gov.uk/def/school" ;
  
  api:variable [
    a api:Variable ;
    api:name "base" ;
    api:value "http://education.data.gov.uk/id" ;
  ] ;
  
  api:endpoint [
    ...
  ], [
    ...
  ] .
}}}

===Vocabulary===

{{{
api:API a rdfs:Class ;
  rdfs:label "API"@en .

api:sparqlEndpoint a rdf:Property ;
  rdfs:label "SPARQL endpoint"@en ;
  rdfs:comment "The endpoint used to serve up the results that are exposed by the API. This should not include the query parameters within the URI."@en ;
  rdfs:domain api:API ;
  rdfs:range rdfs:Resource .

api:base a rdf:Property ;
  rdfs:label "Base URI"@en ;
  rdfs:comment "The base URI of the API, which is distinct from the URI of the SPARQL endpoint that it queries or the base URI of the instances that it returns. This base URI is stripped from the request URI before any matching is done against the endpoints defined for the API."@en ;
  rdfs:domain api:API ;
  rdfs:range rdfs:Literal .

api:contentNegotiation a rdf:Property ;
  rdfs:label "Content Negotiation"@en ;
  rdfs:comment "The mechanism used within the URI to override normal content negotiation and deliver a particular results format."
  rdfs:domain api:API ;
  rdfs:range api:ContentNegotiationStrategy .

api:vocabulary a rdf:Property ;
  rdfs:label "Vocabulary"@en ;
  rdfs:comment "A vocabulary that should be used by the configuration to provide labels for properties. To be recognised for filtering, a property must be defined either within this vocabulary or in the configuration file itself."@en ;
  rdfs:domain api:API ;
  rdfs:range rdfs:Resource .

api:maxPageSize a rdf:Property ;
  rdfs:label "Maximum Page Size"@en ;
  rdfs:comment "The maximum size of lists that will be returned by the API."@en ;
  rdfs:domain api:API ;
  rdfs:range xsd:integer .

api:defaultPageSize a rdf:Property ;
  rdfs:label "Default Page Size"@en ;
  rdfs:comment "The default size of lists that will be returned by the API or endpoint."@en ;
  rdfs:range xsd:integer .

api:ContentNegotiationStrategy a rdfs:Class ;
  rdfs:label "Content negotiation type"@en .

api:suffixBased a api:ContentNegotiationStrategy ;
  rdfs:label "Suffix-Based Content Negotiation"@en ;
  rdfs:comment "This content negotiation strategy uses the suffix used on the last segment within the request URI to indicate the formatter that should be used to format the results of the request."@en .

api:parameterBased a api:ContentNegotiationStrategy ;
  rdfs:label "Parameter-Based Content Negotiation"@en ;
  rdfs:comment "This content negotiation strategy uses the _format parameter within the URI to indicate the formatter that should be used to format the results of the request."@en .
  
api:endpoint a rdf:Property ;
  rdfs:label "Endpoint"@en ;
  rdfs:comment "An endpoint specified by the API, against which requests can be made."@en ;
  rdfs:domain api:API ;
  rdfs:range api:Endpoint .
}}}

==Endpoints==

An `api:Endpoint` describes an endpoint against which requests can be made.

There are two types of end points:

  * `api:ItemEndpoint`s are endpoints that serve up individual items
  * `api:ListEndpoint`s are endpoints that serve up lists of items

Both types of endpoints can specify `api:viewer`s and `api:formatter`s for determining which properties of the item(s) should be exposed and how the resulting RDF graph should be formatted.

Item endpoints need a way of mapping the incoming URI to the URI of the item. This is provided through the `api:itemTemplate` property, which is a template that is completed using the in-scope variables on the endpoint.

List endpoints need a way of determining which items belong to a list. This is provided through a `api:Selector` indicated through the `api:selector` property.

All endpoints can have the following properties:

  * `api:uriTemplate` a template for a URI that the endpoint is used for. Within the template, variable names specified within curly braces are used to bind variables that can be used elsewhere.
  * `api:viewer` a viewer that can be used to view the item(s)
  * `api:defaultViewer` the viewer that will be used if no viewer is specified directly within the parameters passed in the request
  * `api:formatter` a formatter that can be used to format the result of the RDF graph
  * `api:defaultFormatter` the formatter that will be used if no formatter is specified directly in the request, either through the `Accept` header or through the suffix on the last path segment of the URI or through the `_format` parameter

===Examples===

{{{
[] a api:ItemEndpoint ;
  api:uriTemplate "school/{code}" ;
  api:itemTemplate "{base}/school/{code}" ;
  api:defaultViewer api:labelledDescription .

[] a api:ListEndpoint ;
  api:uriTemplate "school" ;
  api:selector [
    api:pattern "type=school" ;
  ] ;
  api:defaultViewer [
    api:name "basic" ;
    api:properties "name,type,localAuthority.name" ;
  ] .
}}}

===Vocabulary===

{{{
api:Endpoint a rdfs:Class ;
  rdfs:label "Endpoint"@en ;
  rdfs:comment "An endpoint exposed by the API."@en .

api:ItemEndpoint a rdfs:Class ;
  rdfs:label "Item Endpoint"@en ;
  rdfs:comment "An endpoint that returns information about a single instance."@en ;
  rdfs:subClassOf api:Endpoint .

api:ListEndpoint a rdfs:Class ;
  rdfs:label "List Endpoint"@en ;
  rdfs:comment "An endpoint that returns information about a list of instances."@en ;
  rdfs:subClassOf api:Endpoint .

api:uriTemplate a rdf:Property ;
  rdfs:label "URI template"@en ;
  rdfs:comment "A template that can be used to match against request URIs. This template can contain variable names within {}s; when the URI is matched then the substrings that appear in these locations are bound to the named variable."@en ;
  rdfs:domain api:Endpoint ;
  rdfs:range rdfs:Literal .

api:itemTemplate a rdf:Property ;
  rdfs:label "Item template"@en ;
  rdfs:comment "A template for the URI of the item that the item endpoint should return. Any instances of {varName} within the string are replaced by the value of the relevant variable."@en ;
  rdfs:domain api:ItemEndpoint ;
  rdfs:range rdfs:Literal .

api:selector a rdf:Property ;
  rdfs:label "Selector"@en ;
  rdfs:comment "The selector that should be used to generate the list of items."@en ;
  rdfs:domain api:ListEndpoint ;
  rdfs:range rdfs:Literal .

api:viewer a rdf:Property ;
  rdfs:label "Viewer"@en ;
  rdfs:comment "A viewer that can be used with the endpoint."@en ;
  rdfs:domain api:Endpoint ;
  rdfs:range api:Viewer .

api:defaultViewer a rdf:Property ;
  rdfs:label "Default Viewer"@en ;
  rdfs:comment "The default viewer used if none is explicitly selected within the request URI."@en ;
  rdfs:domain api:Endpoint ;
  rdfs:range api:Viewer .

api:formatter a rdf:Property ;
  rdfs:label "Formatter"@en ;
  rdfs:comment "A formatter that can be used with the endpoint."@en ;
  rdfs:domain api:Endpoint ;
  rdfs:range api:Formatter .

api:defaultFormatter a rdf:Property ;
  rdfs:label "Default Formatter"@en ;
  rdfs:comment "The default formatter used if none is explicitly selected within the request URI."@en ;
  rdfs:domain api:Endpoint ;
  rdfs:range api:Formatter .
}}}

==Selectors==

Selectors are used to select items that belong to a list. They have the following properties:

  * `api:parent` points to another selector that this one specialises
  * `api:select` holds a WHERE clause followed by an ORDER BY clause and is used to select items using SPARQL
  * `api:where` holds a [http://www.w3.org/TR/rdf-sparql-query/#rGroupGraphPattern GroupGraphPattern] which is used to construct a WHERE clause
  * `api:orderBy` holds a space separated list of [http://www.w3.org/TR/rdf-sparql-query/#rOrderCondition OrderConditions] which are used to construct an ORDER BY clause
  * `api:filter` specifies a set of parameter bindings using the same syntax as is found in a URI query, using property paths
  * `api:sort` specifies a comma-separated list of sort specifications, using property paths

===Examples===

{{{
_:schools a api:Selector ;
  api:filter "type=school" ;
  api:sort "name" .

_:primarySchools a api:Selector ;
  api:parent _:schools ;
  api:filter "type=primary" ;

rdf:type a rdf:Property ;
  api:label "type" ;
  rdfs:range rdfs:Resource .

sch:School a rdfs:Class ;
  api:label "school" .

sch:PrimarySchool a rdfs:Class ;
  api:label "primary" .
}}}

===Vocabulary===

{{{
api:Selector a rdfs:Class ;
  rdfs:label "Selector"@en ;
  rdfs:comment "A specification of an ordered list of resources."@en .

api:parent a rdf:Property ;
  rdfs:label "Parent"@en ;
  rdfs:comment "The parent selector, from which filters and sort specifications may be inherited."@en ;
  rdfs:domain api:Selector ;
  rdfs:range api:Selector .

api:select a rdf:Property ;
  rdfs:label "Select"@en ;
  rdfs:comment "A SPARQL WHERE and ORDER BY clause that can be used to select an ordered list of resources. It should include the binding of an ?item variable for the selected items."@en ;
  rdfs:domain api:Selector ;
  rdfs:range rdf:PlainLiteral .

api:where a rdf:Property ;
  rdfs:label "Where"@en ;
  rdfs:comment "A GroupGraphPattern suitable for embedding within a SPARQL WHERE clause. This is used for filtering the set of items that the selector selects."@en ;
  rdfs:domain api:Selector ;
  rdfs:range rdf:PlainLiteral .

api:orderBy a rdf:Property ;
  rdfs:label "Order By"@en ;
  rdfs:comment "A space separated sequence of OrderConditions suitable for using in a SPARQL ORDER BY clause. This is used to order the sequence of items that the selector selects."@en ;
  rdfs:domain api:Selector ;
  rdfs:range rdf:PlainLiteral .

api:filter a rdf:Property ;
  rdfs:label "Filter"@en ;
  rdfs:comment "A set of parameter bindings in the same format as is used within the query of a URI, used to provide a simple way of filtering the sequence of items that the selector selects."@en ;
  rdfs:domain api:Selector ;
  rdfs:range rdf:PlainLiteral .

api:sort a rdf:Property ;
  rdfs:label "Sort"@en ;
  rdfs:comment "A sequence of comma-separated sort specifications indicating the sorting of the items in the sequence that the selector selects. A leading hyphen indicates a reverse sort."@en ;
  rdfs:domain api:Selector ;
  rdfs:range rdf:PlainLiteral .
}}}

==Viewers==

Viewers are used to construct a graph based on the properties of the selected items. They have the following properties:

  * `api:name` holds the name of the viewer.
  * `api:template` holds a pattern in SPARQL syntax (specifically [http://www.w3.org/TR/rdf-sparql-query/#rConstructTriples ConstructTriples]) that should be used to construct the graph
  * `api:property` indicates properties or lists of properties that should be used as property chains to identify the information to include
  * `api:properties` holds a comma-separated list of property paths that can be used to identify the information to include
  * `api:include` points to other viewers that define properties that should be shown

===Examples===

{{{
_:contactViewer a api:Viewer ;
  api:name "contact" ;
  api:properties "name,number,address.street,address.region,address.city,address.postcode" .

_:adminViewer a api:Viewer ;
  api:name "admin" ;
  api:property
    rdfs:label ,
    skos:notation ,
    (sch:localAuthority rdfs:label) ,
    (sch:localAuthority skos:notation) .

_:detailsViewer a api:Viewer ;
  api:name "details" ;
  api:include _:contactViewer, _:adminViewer .
}}}

===Vocabulary===

{{{
api:Viewer a rdfs:Class ;
  rdfs:label "Viewer"@en ;
  rdfs:comment "A specification of a view of a particular item."@en .

api:describeViewer a api:Viewer ;
  rdfs:label "DESCRIBE Viewer"@en ;
  rdfs:comment "A viewer that returns a graph created from a DESCRIBE query."@en ;
  api:name "describe" .

api:labelledDescribeViewer a api:Viewer ;
  rdfs:label "Labelled DESCRIBE Viewer"@en ;
  rdfs:comment "A viewer that returns the graph created from a DESCRIBE query, supplemented by labels for linked resources."@en ;
  api:name "labelledDescribe" .

api:basicViewer a api:Viewer ;
  rdfs:label "Basic Viewer"@en ;
  rdfs:comment "A viewer that returns the type and label of the item."@en ;
  api:name "basic" ;
  api:property rdfs:label, rdf:type .

api:name a rdf:Property ;
  rdfs:label "Name"@en ;
  rdfs:comment "The name of the resource."@en ;
  rdfs:range rdf:PlainLiteral .

api:include a rdf:Property ;
  rdfs:label "Include"@en ;
  rdfs:comment "Other viewers that describe properties that should be incorporated into this view."@en ;
  rdfs:domain api:Viewer ;
  rdfs:range api:Viewer .

api:template a rdf:Property ;
  rdfs:label "Template"@en ;
  rdfs:comment "SPARQL that can be used to construct a graph based on an item (identified in the SPARQL as ?item)."@en ;
  rdfs:domain api:Viewer ;
  rdfs:range rdf:PlainLiteral .

api:property a rdf:Property ;
  rdfs:label "Property"@en ;
  rdfs:comment "A property chain (which may be a single property) that indicates information that should be included in the view."@en ;
  rdfs:domain api:Viewer ;
  rdfs:range rdfs:Resource .

api:properties a rdf:Property ;
  rdfs:label "Properties"@en ;
  rdfs:comment "A comma-separated list of property paths that indicate the information that should be included in the view."@en ;
  rdfs:domain api:Viewer ;
  rdfs:range rdf:PlainLiteral .
}}}

==Formatters==

Formatters determine how an RDF graph is serialised into a response. Each formatter has:

  * a `api:name` which is used to identify the formatter within the `_format` URI parameter or as the suffix if suffixes are used
  * a `api:mimeType` which is the mime type of the response

Other properties may be specified for the formatter, depending on its type. For example, instances of `api:XsltFormatter` will have a `api:stylesheet` property.

===Examples===

{{{
_:schoolHTMLformatter a api:XsltFormatter ;
  api:name "html" ;
  api:mimeType "text/html" ;
  api:stylesheet </styles/school-to-html.xsl> .
}}}

===Vocabulary===

{{{
api:Formatter a rdfs:Class ;
  rdfs:label "Formatter"@en ;
  rdfs:comment "A formatter that creates a representation from an RDF graph."@en .

api:mimeType a rdf:Property ;
  rdfs:label "Mime Type"@en ;
  rdfs:comment "The mime type that the formatter returns and that it should be used with."@en ;
  rdfs:domain api:Formatter ;
  rdfs:range rdf:PlainLiteral .

api:RdfXmlFormatter a rdfs:Class ;
  rdfs:label "RDF/XML Formatter"@en ;
  rdfs:comment "A formatter that generates an RDF/XML representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:rdfXmlFormatter a api:RdfXmlFormatter ;
  rdfs:label "Default RDF/XML Formatter"@en ;
  rdfs:comment "A formatter that gives the default RDF/XML representation of an RDF graph"@en ;

api:TurtleFormatter a rdfs:Class ;
  rdfs:label "Turtle Formatter"@en ;
  rdfs:comment "A formatter that generates an Turtle representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:TurtleFormatter a api:TurtleFormatter ;
  rdfs:label "Default Turtle Formatter"@en ;
  rdfs:comment "A formatter that gives the default Turtle representation of an RDF graph"@en ;

api:JsonFormatter a rdfs:Class ;
  rdfs:label "JSON Formatter"@en ;
  rdfs:comment "A formatter that generates a simple JSON representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:jsonFormatter a api:jsonFormatter ;
  rdfs:label "Default JSON Formatter"@en ;
  rdfs:comment "A formatter that gives the default simple JSON representation of an RDF graph"@en ;

api:XmlFormatter a rdfs:Class ;
  rdfs:label "XML Formatter"@en ;
  rdfs:comment "A formatter that generates a simple XML representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:xmlFormatter a api:xmlFormatter ;
  rdfs:label "Default XML Formatter"@en ;
  rdfs:comment "A formatter that gives the default simple XML representation of an RDF graph"@en ;

api:CsvFormatter a rdfs:Class ;
  rdfs:label "CSV Formatter"@en ;
  rdfs:comment "A formatter that generates a simple CSV representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:csvFormatter a api:csvFormatter ;
  rdfs:label "Default CSV Formatter"@en ;
  rdfs:comment "A formatter that gives the default simple CSV representation of an RDF graph"@en ;

api:XsltFormatter a rdfs:Class ;
  rdfs:label "XSLT Formatter"@en ;
  rdfs:comment "A formatter that uses an XSLT stylesheet to generates a representation of an RDF graph"@en ;
  rdfs:subClassOf api:Formatter .

api:stylesheet a rdf:Property ;
  rdfs:label "Stylesheet"@en ;
  rdfs:comment "The XSLT stylesheet that should be used by an XSLT formatter to generate a representation of the RDF graph"@en ;
  rdfs:domain api:XsltFormatter ;
  rdfs:range rdfs:Resource .
}}}