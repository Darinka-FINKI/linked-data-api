#summary Selecting an outout format and serialising results to the client

<wiki:toc max_depth="3" />

=Formatting Graphs=

The representation that is finally returned for a request is determined by a Formatter.

An API may have a number of formatters available for generating responses for a request. Clients may choose from amongst these formatters using content negotiation.

== Built-In Formatters ==

This specification defines five types of "built-in" Formatters that produce outputs in a range of different serialisations. 

Conforming implementations MUST support the RDF and JSON formatters and SHOULD support the additional formatters in order to provide clients with additional flexibility in quering an API. 

The XSLT Formatter provides a built-in extension point for supporting a range of additional serializations through transformation of the simple XML format.

The following table identifies the five built in formatters. Each formatter is listed along with its name, its URI, the mimetype it generates, and whether implementations are required to support it:

|| Description || Name || URI || Mimetype || Required? ||
|| RDF Formatter || `rdf` || `api:RdfXmlFormatter` ||`application/rdf+xml`|| Yes ||
|| JSON Formatter || `json` || `api:JsonFormatter` ||`application/json`|| Yes ||
|| Turtle Formatter || `ttl` || `api:TurtleFormatter` || `text/turtle` || No ||
|| XML Formatter || `xml` || `api:XmlFormatter` || `application/xml` || No ||
|| XSLT Formatter || N/A  || `api:XsltFormatter` || N/A || No ||

The XSLT Formatter does not specify a name or a mimetype. Instances of that formatter are intended to be configured with a name and mimetype appropriate to the XSLT stylesheet used to serialize the results.

Implementations may support other formatter types, or support additional configuration of the built-in formatter types through implementation-specific properties as long as their basic behaviours remain unchanged.

== Formatter Configuration ==

For a request to an endpoint, the list of possible formatters is constructed from:

  * the built-in formatters supported by the API implementation
  * the `api:defaultFormatter` property on the API
  * the `api:formatter` property on the API
  * the `api:defaultFormatter` property on the selected endpoint
  * the `api:formatter` property on the selected endpoint

Two formatters may have the same name, indicated by the `api:name` property. A formatter lower in this list overrides the one from higher in the list.

For example a `'json'` formatter defined on an Endpoint will override the built-in `'json'` formatter.

== Formatter Selection ==

The formatter that is to be used when producing results from a request is determined as follows:

  * if the `_format` request parameter is specified, and the API's `api:contentNegotiation` property is `api:parameterBased`, the formatter named in that parameter. If there is no such formatter, a `400 Bad Request` response is given.

_der: Is the `api:contentNegotiation` necessary? Why not just allow dot and `_format` notation freely?_

_JT: What if they clash? Which takes precedence? Or you do get a 400 error if that happens?_

  * otherwise, if the last path segment in the request URI uses an extension, such as `.ttl`, the formatter name is the one given after the final dot in that path segment. If there is no such formatter, continue (note that in this case the suffix will not be stripped from the request path prior to matching against endpoint URIs).
  * otherwise, use the `Accept` header in the request to perform content negotiation based on the `api:mimeType` properties of the available formatters _(JT: This is under-specified at the moment: if there are multiple formatters that match the Accept header, which gets used?)_
  * otherwise, if the endpoint contains a `api:defaultFormatter`, use that
  * otherwise, if the API contains a `api:defaultFormatter`, use that
  * otherwise use the `api:jsonFormatter`

== Formatter Inputs ==

A Formatter component is passed the following logical parameters when executed:

  * the RDF graph constructed by the viewer
  * the URI of the root resource in the graph: in the case of an item endpoint, this is the item itself; in the case of a list endpoint, it is the current page
  * the variable bindings, as described above
  * the prefix bindings present within the configuration file

Implementations are free to pass these parameters to the formatter in whatever manner is best suited. Additional parameters or context can also be made available.

= Output Formats =

__TODO Example data/inputs.__

==RDF/XML Formatting==

RDF/XML formatters should create [http://www.w3.org/TR/rdf-syntax-grammar/ RDF/XML]. 

They should use the prefix bindings that they are passed as namespace declarations within the RDF/XML.

==Turtle Formatting==

Turtle formatters should create [http://www.w3.org/TeamSubmission/turtle/ Turtle]. 

They should use the prefix bindings that they are passed as prefix declarations within the Turtle.

==JSON Formatting==

__TODO: separate document/schema?__

The JSON formatter creates a simple JSON format based on the RDF graph that it's given.

The result is a single object, that looks like:

{{{
{
  "format": "linked-data-api" ;
  "version": "0.2" ;
  "result": {
    ...
  }
}
}}}

_der: The current implementation also includes the "context" property which provides the name/uri mapping and inferred type information for every property. See GoogleCode. This enables round tripping for well-behaved RDF. While round tripping is a non-goal at this stage we-Epimorphics need a simple update version of the protocol and including the context enables that. As a side effect the context also means that all the available properties are communicated to the client._

_JT: The disadvantage is that it can add a huge amount of weight to the JSON representation, at least in its current form. Putting the information at the metadata endpoint makes it accessible (for the purposes of round-tripping) without having the repetitive burden in every single document._

The resource described in the `result` property is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto JSON objects as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the object is given a `_id` property that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the object is given a `_about` property that contains the URI of the resource

The RDF properties of a resource are mapped onto JSON properties. The name of the JSON property is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The value of the JSON property is an array if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto a JSON value as follows:

  * if the `api:structured` property of the RDF property has the value `true` then the value is represented as an object with a `_value` property holding the value itself, and `_lang` or `_datatype` properties holding the language code and the short name of the datatype as applicable
  * otherwise, if the value has a datatype of `xsd:boolean`, it becomes `true` or `false`
  * otherwise, if the value has a numeric datatype (one of the XML Schema numeric datatypes), it becomes a number in the JSON
  * otherwise, if the value has the datatype `xsd:dateTime` it is mapped to a string in the date/time format recognised by `Date.parse`, namely `EEE, d MMM yyyy HH:mm:ss 'GMT'Z`
  * otherwise, if the value has the datatype `xsd:date` it is mapped to a string in the date format recognised by `Date.parse`, namely `yyyy-MM-dd`
  * otherwise, if the value is a `rdf:List`, it is mapped to an array whose items are the result of mapping the members of the list to JSON
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto a JSON object as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto a JSON object with no properties
  * otherwise, if the value is a resource it is mapped onto a string whose value is the URI of the resource
  * otherwise, if the JSON property is an array (because the RDF property has multiple values or is marked as multi-valued) then the value is represented as a string; if the value has a language then `@{lang}` is appended to the string; if the value has a datatype then `^^{datatype}` is appended to the string
  * otherwise (the value is a literal that isn't a boolean or number), it is mapped onto a string

==XML Formatting==

The XML formatter creates an XML representation that is very similar to the JSON representation. The outermost object is a `<result>` element with `format` and `version` attributes.

The resource described in the `<result>` element is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto XML elements as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the element is given a `id` attribute that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the element is given an `href` attribute that contains the URI of the resource

The RDF properties of a resource are mapped onto XML elements. The name of the XML element is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The contents of the XML element is a sequence of `<list>` elements if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto some XML content as follows:

  * if the value is a literal, it is mapped to a text node holding the value itself; `lang` or `datatype` attributes on the element hold the language code and the short name of the datatype as applicable
  * otherwise, if the value is a `rdf:List`, it is mapped to a sequence of `<item>` elements, one representing each of the results of mapping the members of the list to XML
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto an XML element as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto an empty XML element (with an `id` attribute if it it referenced more than once)
  * otherwise, if the value is a resource the element is given an `href` attribute whose value is the URI of the resource

==XSLT Formatting==

XSLT formatters create representations by taking the simple XML generated by the default XML formatter (`api:xmlFormatter`) and transforming it using the stylesheet specified by the `api:stylesheet` property of the XSLT formatter.

The XSLT stylesheet is passed an `$api:namespaces` parameter which contains an XML document in the format:

{{{
<namespaces>
  <namespace prefix="{prefix}">{value}</namespace>
  ... other namespaces ...
</namespaces>
}}}

It is also passed a parameter for each of the variable bindings, with the name equal to the variable name and the value being the string value of the variable.