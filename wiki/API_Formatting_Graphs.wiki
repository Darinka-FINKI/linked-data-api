#summary Serialising results to the client

==Formatting Graphs==

The representation that is finally returned for a request is determined by a formatter. A list of possible formatters is constructed from:

  * the built-in formatters supported by the implementation
  * the `api:defaultFormatter` property on the API
  * the `api:formatter` property on the API
  * the `api:defaultFormatter` property on the selected endpoint
  * the `api:formatter` property on the selected endpoint

If two formatters have the same name (indicated by `api:name`) then the one from lower in the list overrides the one from higher in the list. For example, a `'json'` formatter defined on an endpoint will override the built-in `'json'` formatter.

The formatter that is used is determined as follows:

  * if the `_format` request parameter is specified, and the API's `api:contentNegotiation` property is `api:parameterBased`, the formatter named in that parameter. If there is no such formatter, a `400 Bad Request` response is given.

_der: Is the `api:contentNegotiation` necessary? Why not just allow dot and `_format` notation freely?_

_JT: What if they clash? Which takes precedence? Or you do get a 400 error if that happens?_

  * otherwise, if the last path segment in the request URI uses an extension, such as `.ttl`, the formatter name is the one given after the final dot in that path segment. If there is no such formatter, continue (note that in this case the suffix will not be stripped from the request path prior to matching against endpoint URIs).
  * otherwise, use the `Accept` header in the request to perform content negotiation based on the `api:mimeType` properties of the available formatters _(JT: This is under-specified at the moment: if there are multiple formatters that match the Accept header, which gets used?)_
  * otherwise, if the endpoint contains a `api:defaultFormatter`, use that
  * otherwise, if the API contains a `api:defaultFormatter`, use that
  * otherwise use the `api:jsonFormatter`

The formatter itself is passed:

  * the RDF graph constructed by the viewer
  * the root resource in the graph: in the case of an item endpoint, this is the item itself; in the case of a list endpoint, it is the current page
  * the variable bindings, as described above
  * the prefix bindings present within the configuration file

There are five types of built-in formatter, with the `api:XsltFormatter` providing flexibility for programmatic addition of different formats as required:

  * `api:RdfXmlFormatter` instances are formatters that generate RDF/XML
  * `api:TurtleFormatter` instances are formatters that generate Turtle
  * `api:JsonFormatter` instances are formatters that generate simple JSON
  * `api:XmlFormatter` instances are formatters that generate simple XML
  * `api:XsltFormatter` instances are formatters that use XSLT stylesheets to format the results

Implementations must support `api:RdfXmlFormatter`s and `api:JsonFormatter`s. Support for the other formatter types is optional. Implementations may support other formatter types, or support additional configuration of the built-in formatter types through implementation-specific properties as long as their basic behaviours remain unchanged.

===RDF/XML Formatting===

RDF/XML formatters should create [http://www.w3.org/TR/rdf-syntax-grammar/ RDF/XML]. They should use the prefix bindings that they are passed as namespace declarations within the RDF/XML.

===Turtle Formatting===

Turtle formatters should create [http://www.w3.org/TeamSubmission/turtle/ Turtle]. They should use the prefix bindings that they are passed as prefix declarations within the Turtle.

===JSON Formatting===

The JSON formatter creates a simple JSON format based on the RDF graph that it's given.

The result is a single object, that looks like:

{{{
{
  "format": "linked-data-api" ;
  "version": "0.2" ;
  "result": {
    ...
  }
}
}}}

_der: The current implementation also includes the "context" property which provides the name/uri mapping and inferred type information for every property. See GoogleCode. This enables round tripping for well-behaved RDF. While round tripping is a non-goal at this stage we-Epimorphics need a simple update version of the protocol and including the context enables that. As a side effect the context also means that all the available properties are communicated to the client._

_JT: The disadvantage is that it can add a huge amount of weight to the JSON representation, at least in its current form. Putting the information at the metadata endpoint makes it accessible (for the purposes of round-tripping) without having the repetitive burden in every single document._

The resource described in the `result` property is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto JSON objects as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the object is given a `_id` property that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the object is given a `_about` property that contains the URI of the resource

The RDF properties of a resource are mapped onto JSON properties. The name of the JSON property is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The value of the JSON property is an array if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto a JSON value as follows:

  * if the `api:structured` property of the RDF property has the value `true` then the value is represented as an object with a `_value` property holding the value itself, and `_lang` or `_datatype` properties holding the language code and the short name of the datatype as applicable
  * otherwise, if the value has a datatype of `xsd:boolean`, it becomes `true` or `false`
  * otherwise, if the value has a numeric datatype (one of the XML Schema numeric datatypes), it becomes a number in the JSON
  * otherwise, if the value has the datatype `xsd:dateTime` it is mapped to a string in the date/time format recognised by `Date.parse`, namely `EEE, d MMM yyyy HH:mm:ss 'GMT'Z`
  * otherwise, if the value has the datatype `xsd:date` it is mapped to a string in the date format recognised by `Date.parse`, namely `yyyy-MM-dd`
  * otherwise, if the value is a `rdf:List`, it is mapped to an array whose items are the result of mapping the members of the list to JSON
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto a JSON object as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto a JSON object with no properties
  * otherwise, if the value is a resource it is mapped onto a string whose value is the URI of the resource
  * otherwise, if the JSON property is an array (because the RDF property has multiple values or is marked as multi-valued) then the value is represented as a string; if the value has a language then `@{lang}` is appended to the string; if the value has a datatype then `^^{datatype}` is appended to the string
  * otherwise (the value is a literal that isn't a boolean or number), it is mapped onto a string

===XML Formatting===

The XML formatter creates an XML representation that is very similar to the JSON representation. The outermost object is a `<result>` element with `format` and `version` attributes.

The resource described in the `<result>` element is the entry point into the graph, as described above (the item for an item endpoint, the page for a list endpoint).

Resources are mapped onto XML elements as follows:

  * if the resource is a blank node that is the object or more than one statement within the graph, the element is given a `id` attribute that contains a unique identifier for that blank node
  * otherwise, if the resource is not a blank node, the element is given an `href` attribute that contains the URI of the resource

The RDF properties of a resource are mapped onto XML elements. The name of the XML element is:

  * the short name for the property, as described in the property paths section, if it has one
  * the `rdfs:label` of the property, if it is a legal short name for a property that doesn't clash with an existing name
  * the local name of the property (the part after the last hash or slash), if it is a legal short name for a property that doesn't clash with an existing name
  * the prefix associated with the namespace of the property (the part before the last hash or slash), concatenated with an underscore, concatenated with the local name of the property

The contents of the XML element is a sequence of `<list>` elements if the RDF property has more than one value in the RDF graph or if the `api:multiValued` property of the RDF property has the value `true`.

Each RDF value is mapped onto some XML content as follows:

  * if the value is a literal, it is mapped to a text node holding the value itself; `lang` or `datatype` attributes on the element hold the language code and the short name of the datatype as applicable
  * otherwise, if the value is a `rdf:List`, it is mapped to a sequence of `<item>` elements, one representing each of the results of mapping the members of the list to XML
  * otherwise, if the value is a resource which is the subject of a statement in the RDF graph, it is mapped onto an XML element as described here
  * otherwise, if the value is a blank node with no properties it is mapped onto an empty XML element (with an `id` attribute if it it referenced more than once)
  * otherwise, if the value is a resource the element is given an `href` attribute whose value is the URI of the resource

===XSLT Formatting===

XSLT formatters create representations by taking the simple XML generated by the default XML formatter (`api:xmlFormatter`) and transforming it using the stylesheet specified by the `api:stylesheet` property of the XSLT formatter.

The XSLT stylesheet is passed an `$api:namespaces` parameter which contains an XML document in the format:

{{{
<namespaces>
  <namespace prefix="{prefix}">{value}</namespace>
  ... other namespaces ...
</namespaces>
}}}

It is also passed a parameter for each of the variable bindings, with the name equal to the variable name and the value being the string value of the variable.